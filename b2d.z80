; ----------------------------------------------------------------
; Calling convention. Callee must preserve IX, IY (except for "me")
; callee may clobber AF, BC, DE, HL (caller preserved)
; args (and return value) are passed in as static variables eg ClipSegmentToLine_offset
; or Transpose_mat (which is a Mat22 struct passed by value so we can't use a register)
; exception is pointers which are often passed in as IX, IY, HL
; local variables are static variables (labels). 
; We don't use the stack to pass in args or store local variables (no stackframe)
;
; NB: for ZX Spin don't put code in first column or it might be mistaken for a label!
; Note the use of $+x or $-x in relative jumps within f24, not what you might think!
; ----------------------------------------------------------------

; ----------------------------------------------------------------
; Defines structs and enums
; ----------------------------------------------------------------

; struct Vec2
Vec2 equ 6
Vec2_x equ 0
Vec2_y equ 3

; struct Mat22
Mat22 equ 12
Mat22_col1 equ 0
Mat22_col2 equ 6

; struct Edges
Edges equ 4
Edges_inEdge1 equ 0
Edges_outEdge1 equ 1
Edges_inEdge2 equ 2
Edges_outEdge2 equ 3

; struct ClipVertex
ClipVertex equ 10
ClipVertex_v equ 0   ; Vec2
ClipVertex_fp equ 6  ; Edges

; enum Axis
FACE_A_X equ 0
FACE_A_Y equ 1
FACE_B_X equ 2
FACE_B_Y equ 3

; enum EdgeNumbers
NO_EDGE equ 0
EDGE1 equ 1
EDGE2 equ 2
EDGE3 equ 3
EDGE4 equ 4

; struct Body (3 bytes=float, 6=Vec2)
Body equ 48
Body_position equ 0 ; 6
Body_rotation equ 6 ; 3
Body_velocity equ 9 ; 6
Body_angularVelocity equ 15 ; 3
Body_force equ 18 ; 6
Body_torque equ 24 ; 3
Body_width equ 27 ; 6
Body_friction equ 33 ; 3
Body_mass equ 36 ; 3
Body_invMass equ 39 ;3
Body_I equ 42 ;3
Body_invI equ 45 ;3

; struct Contact
Contact equ 49
Contact_position equ 0 ;6
Contact_normal equ 6 ; 6
Contact_r1 equ 12 ; 6
Contact_r2 equ 18 ; 6
Contact_separation equ 24 ; 3
Contact_Pn equ 27 ; 3
Contact_Pt equ 30 ; 3
Contact_Pnb equ 33 ; 3
Contact_massNormal equ 36 ; 3
Contact_massTangent equ 39 ; 3
Contact_bias equ 42 ; 3
Contact_feature equ 45 ; 4 (Edges)

; struct Arbiter
Arbiter equ 106
Arbiter_contacts equ 0 ; 49*2
Arbiter_numContacts equ 98 ; 1
Arbiter_body1 equ 99 ; 2
Arbiter_body2 equ 101 ; 2
Arbiter_friction equ 103 ; 3

; struct ArbiterKey
ArbiterKey equ 4
ArbiterKey_body1 equ 0 ; 2 
ArbiterKey_body2 equ 2 ; 2 

g_bodies: ds 20*2
g_numBodies: db 0

g_arbiters: ds 20*Arbiter
g_arbiterKeys: ds 20*ArbiterKey
g_numArbiters: ds 1

gravity: ds Vec2
iterations: ds 1

; ----------------------------------------------------------
; struct Arbiter* findArbiter(struct ArbiterKey key)
; return through hl
; ----------------------------------------------------------

findArbiter_key: ds ArbiterKey
findArbiter_ret: ds 2
findArbiter:

  push ix
  push iy

  ld a,(g_numArbiters)
  cp 0
  jr z,findArbiter_break
  ld b,a  
  
  ld ix,g_arbiterKeys
  ld iy,g_arbiters

findArbiter_loop:
  ld l,(ix+ArbiterKey_body1)
  ld h,(ix+ArbiterKey_body1+1)
  
  ld de,(findArbiter_key)

  ld a,h
  cp d
  jr nz, findArbiter_skip
  
  ld a,l
  cp e  
  jr nz, findArbiter_skip

  ld l,(ix+ArbiterKey_body2)
  ld h,(ix+ArbiterKey_body2+1)
  
  ld de,(findArbiter_key+2)

  ld a,h
  cp d
  jr nz, findArbiter_skip
  
  ld a,l
  cp e  
  jr nz, findArbiter_skip

  push iy
  pop hl
  
  pop iy
  pop ix
  ret
  
findArbiter_skip:  

  ld de,ArbiterKey
  add ix,de
  
  ld de,Arbiter
  add iy,de
  
  djnz findArbiter_loop  

findArbiter_break:
  ld hl,0  
  ld (findArbiter_ret),hl
  
  pop iy
  pop ix
  
  ret

; ---------------------------------------------------------------
; void insertArbiter(struct ArbiterKey key, struct Arbiter value)
; ---------------------------------------------------------------

insertArbiter_key: ds ArbiterKey
insertArbiter_value: ds Arbiter
insertArbiter:

  ld a,(g_numArbiters)
  ld hl,g_arbiterKeys
  ld de,ArbiterKey
  
  call arrayIndex
  
  push hl
  pop de

  ld hl,insertArbiter_key
  ld bc,ArbiterKey
  ldir
  
  ld a,(g_numArbiters)
  ld hl,g_arbiters
  ld de,Arbiter
  
  call arrayIndex
  
  push hl
  pop de

  ld hl,insertArbiter_value
  ld bc,Arbiter
  ldir
  
  inc a
  ld (g_numArbiters),a  

  ret

; ----------------------------------------------------------------
; void eraseArbiter(struct ArbiterKey key)
; ----------------------------------------------------------------

eraseArbiter_key: ds Arbiter
eraseArbiter:

  push ix
  push iy

  ld a,(g_numArbiters)
  cp 0
  jr z,eraseArbiter_break
  
  ld b,a
  ld ix,g_arbiterKeys
  ld iy,g_arbiters
  
eraseArbiter_loop:

  ld l,(ix+ArbiterKey_body1)
  ld h,(ix+ArbiterKey_body1+1)
  
  ld de,(eraseArbiter_key)

  ld a,h
  cp d
  jr nz, eraseArbiter_skip
  
  ld a,l
  cp e  
  jr nz, eraseArbiter_skip

  ld l,(ix+ArbiterKey_body2)
  ld h,(ix+ArbiterKey_body2+1)
  
  ld de,(eraseArbiter_key+2)

  ld a,h
  cp d
  jr nz, eraseArbiter_skip
  
  ld a,l
  cp e  
  jr nz, eraseArbiter_skip
f
;  ld bc,(b-1)*ArbiterKey

  ld c,b
  dec c
  
  jr z,eraseArbiter_skip2 ; at end of array avoid ldir with bc=0

  push bc ; preserve loop counter b
  
  ld b,0  
  ld de,ArbiterKey
  call mul16   ; hl = (b-1)*ArbiterKey
  push hl
  pop bc
  
  push ix
  pop hl
  ld de,ArbiterKey
  add hl,de

  push ix
  pop de
  
  ldir
  
  pop bc
  push bc
  
  ld c,b
  dec c
  ld b,0  
  ld de,Arbiter
  call mul16
  push hl
  pop bc
  
  push ix
  pop hl
  ld de,Arbiter
  add hl,de

  push ix
  pop de
    
  ldir
  
  pop bc ; get b back

eraseArbiter_skip2:
  
  ld a,(g_numArbiters)
  dec a
  ld (g_numArbiters),a
  
eraseArbiter_skip:

  ld de,ArbiterKey
  add ix,de
  
  ld de,Arbiter
  add iy,de
  
  djnz eraseArbiter_loop  

eraseArbiter_break:  
  pop iy
  pop ix
  ret

; -------------------------------------------------------------------
; void initContact(struct Contact *c)
; ix is contact c
; -------------------------------------------------------------------
  
initContact:
  
  ld (ix+Contact_Pn),0
  ld (ix+Contact_Pn+1),0
  ld (ix+Contact_Pn+2),0

  ld (ix+Contact_Pt),0
  ld (ix+Contact_Pt+1),0
  ld (ix+Contact_Pt+2),0

  ld (ix+Contact_Pnb),0
  ld (ix+Contact_Pnb+1),0
  ld (ix+Contact_Pnb+2),0
  
  ret

; ---------------------------------------------------------------
; void UpdateArbiter(struct Arbiter *a, struct Contact* newContacts, int numNewContacts)
; ix = a
; iy = newContacts = cNew
; a = numNewContacts
; ----------------------------------------------------------------

UpdateArbiter_mergedContacts: ds Contact*2

UpdateArbiter:

  push af
  push ix
  
  ld ix,UpdateArbiter_mergedContacts
  call initContact
  
  ld ix,UpdateArbiter_mergedContacts+Contact
  call initContact  
  
  pop ix
  push ix
  push iy

  cp 0
  jr z,UpdateArbiter_break    
  ld b,a ; numNewContacts
  
  ld hl,UpdateArbiter_mergedContacts  ; c for later
  ld c,0; If set to 1, cNew = cOld
  
UpdateArbiter_loop:

  push bc

  ld b,(ix+Arbiter_numContacts) ; ix=Arbiter "a"
  ld a,b
  cp 0
  jr z,UpdateArbiter_break2
  
;  push ix ; store "a"
  ld de,Arbiter_contacts
  add ix,de   ; cOld = a->contacts

UpdateArbiter_loop2:
    
  ld a,(ix+Contact_feature+Edges_inEdge1)
  ld d,a
  ld a,(iy+Contact_feature+Edges_inEdge1)
  cp d
  jr nz, UpdateArbiter_skip

  ld a,(ix+Contact_feature+Edges_outEdge1)
  ld d,a
  ld a,(iy+Contact_feature+Edges_outEdge1)
  cp d
  jr nz, UpdateArbiter_skip

  ld a,(ix+Contact_feature+Edges_inEdge2)
  ld d,a
  ld a,(iy+Contact_feature+Edges_inEdge2)
  cp d
  jr nz, UpdateArbiter_skip

  ld a,(ix+Contact_feature+Edges_outEdge2)
  ld d,a
  ld a,(iy+Contact_feature+Edges_outEdge2)
  cp d
  jr nz, UpdateArbiter_skip

  ld c,1
  jr UpdateArbiter_break2

UpdateArbiter_skip:

  ld de,Contact
  add ix,de
  
  djnz UpdateArbiter_loop2

UpdateArbiter_break2:
;  pop ix ; a

  ld a,c   ; found if c=1
  cp 1
  
  jr nz, UpdateArbiter_skip2

  push hl  ; c (store for later)

  push hl  ; c
  pop de
  
  push iy  ; cNew
  pop hl  
  
  ld bc,Contact
  ldir
  
  pop hl  ; c
  push hl
  
  ld bc,Contact_Pn
  add hl,bc
  push hl
  pop de ; c->Pn
  
  push ix ; cOld
  pop hl
  
  add hl,bc
  ld bc,9
  ldir

  pop hl ; c
    
UpdateArbiter_skip2:

  ld de,Contact
  add iy,de  ; cNew
  add hl,de ; c (mergedContacts)
  
  pop bc
  
  djnz UpdateArbiter_loop
UpdateArbiter_break:
  
  pop iy
  pop ix ; "a"
  pop af; numNewContacts

  push ix
  pop hl
  
  ld de,Arbiter_contacts
  add hl,de
  push hl
  pop de ; a->contacts
  
  ld bc,Contact
  ld e,a
  ld d,0
  call mul16 ; hl=numNewContacts*Contact

  push hl
  pop bc

  ld hl,UpdateArbiter_mergedContacts
  ldir

  ld (ix+Arbiter_numContacts),a
  
  ret
  
; ----------------------------------------------------------------
; void BroadPhase()
; assume at g_numBodies >= 1
; ----------------------------------------------------------------

BroadPhase_newArb: ds Arbiter
BroadPhase_key: ds ArbiterKey
BroadPhase:

  push ix
  push iy

  ld b,0
  ld ix,g_bodies ; bi
  
BroadPhase_loop:
  push bc

  push ix
  pop iy

  ld de,Body
  add iy,de ; bj
  inc b ; start of inner loop
  
BroadPhase_loop2:
  push bc

  ld a,(ix+Body_invMass+0)
  ld h,(ix+Body_invMass+1)
  ld l,(ix+Body_invMass+2)
  
  ld c,0
  ld d,0
  ld e,0
  
  call f24cmp
  
  jr nz, BroadPhase_skip

  ld a,(iy+Body_invMass+0)
  ld h,(iy+Body_invMass+1)
  ld l,(iy+Body_invMass+2)

  call f24cmp
  
  jr nz, BroadPhase_skip

  jp BroadPhase_continue

BroadPhase_skip:

  push ix  ; bi
  pop hl
  
  push iy
  pop de
  
  sbc hl,de ; bi-bj
  
  jr nc,BroadPhase_else
  
  ld (BroadPhase_newArb+Arbiter_body1),ix
  ld (BroadPhase_newArb+Arbiter_body2),iy

  ld (BroadPhase_key+ArbiterKey_body1),ix
  ld (BroadPhase_key+ArbiterKey_body2),iy
  jp BroadPhase_end 

BroadPhase_else:
  ld (BroadPhase_newArb+Arbiter_body1),iy
  ld (BroadPhase_newArb+Arbiter_body2),ix

  ld (BroadPhase_key+ArbiterKey_body1),iy
  ld (BroadPhase_key+ArbiterKey_body2),ix

BroadPhase_end:
  push ix  
  ld ix,BroadPhase_newArb+Arbiter_contacts
  call initContact

  ld de,Contact  
  add ix,de
  call initContact
  pop ix

; int Collide(struct Contact* contacts, struct Body* bodyA, struct Body* bodyB)
; hl=contact, ix=bodyA, iy=bodyB

  ld hl,BroadPhase_newArb+Arbiter_contacts
  ld ix,(BroadPhase_newArb+Arbiter_body1)
  ld iy,(BroadPhase_newArb+Arbiter_body2)
  
  call Collide
  ld (BroadPhase_newArb+Arbiter_numContacts),a
  
  push af
  push ix
  
  ld de,Body_friction
  ld ix,(BroadPhase_newArb+Arbiter_body1)
  add ix,de
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,(BroadPhase_newArb+Arbiter_body2)
  add ix,de
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24mul
;  call f24sqrt

  ld ix,BroadPhase_newArb
  ld (ix+Arbiter_friction),a
  ld (ix+Arbiter_friction+1),h
  ld (ix+Arbiter_friction+2),l

  pop ix
  pop af

  cp 0
  jr z, BroadPhase_else1

  ld de,findArbiter_key
  ld hl,BroadPhase_key
  ld bc,ArbiterKey
  ldir
  call findArbiter ; result in hl

  ld a,h  ; if hl=0, sets z flag
  or l

  jr nz, BroadPhase_else2
  
  ld de,insertArbiter_key
  ld hl,BroadPhase_key
  ld bc,ArbiterKey
  ldir
  
  ld de,insertArbiter_value
  ld hl,BroadPhase_newArb
  ld bc,Arbiter
  ldir
  
  call insertArbiter
  jp BroadPhase_end2  
BroadPhase_else2:

  push ix
  push iy

  push hl
  pop ix
  
  ld iy,BroadPhase_newArb+Arbiter_contacts
  ld a,(BroadPhase_newArb+Arbiter_numContacts)
  
  call UpdateArbiter
  
  pop iy
  pop ix
BroadPhase_end2:

BroadPhase_else1:

  ld de,eraseArbiter_key
  ld hl,BroadPhase_key
  ld bc,ArbiterKey
  ldir
  
  call eraseArbiter
BroadPhase_end1:
  
BroadPhase_continue:
  ld bc,Body
  add iy,bc ; bj
  pop bc
  inc b
  ld a,(g_numBodies)
  cp b
  jp nz, BroadPhase_loop2

  ld bc,Body
  add ix,bc ; bi
  pop bc
  inc b
  ld a,(g_numBodies)
  cp b
  jp nz, BroadPhase_loop

  pop iy
  pop ix
  
  ret
  
; ---------------------------------------------------------
; void PreStep(struct Arbiter *a, float inv_dt)
; a = ix
; ---------------------------------------------------------
  
PreStep_inv_dt: ds 3
PreStep_r1: ds 6
PreStep_r2: ds 6
PreStep_rn1: ds 3
PreStep_rn2: ds 3
PreStep_tangent: ds Vec2
PreStep_b1invM: ds 3
PreStep_b2invM: ds 3
PreStep_b1invI: ds 3
PreStep_b2invI: ds 3

PreStep:
 
  push ix ; a
  push iy
  
  push ix
  pop iy
  add iy,Arbiter_contacts ; c
  
  ld b,(ix+Arbiter_numContacts)
  ld a,b
  cp 0
  jr z,PreStep_break

; a->body1->invMass
  ld l,(ix+ArbiterKey_body1)
  ld h,(ix+ArbiterKey_body1+1)
  
  push hl
  ld de,Body_invMass
  add hl,de
  ld de,PreStep_b1invM
  ld bc,3
  ldir

; a->body1->invI

  pop hl
  ld de,Body_invI
  add hl,de
  ld de,PreStep_b1invI
  ld bc,3
  ldir

; a->body2->invMass
  ld l,(ix+ArbiterKey_body2)
  ld h,(ix+ArbiterKey_body2+1)
  
  push hl
  ld de,Body_invMass
  add hl,de
  ld de,PreStep_b2invM
  ld bc,3
  ldir

; a->body2->invI

  pop hl
  ld de,Body_invI
  add hl,de
  ld de,PreStep_b2invI
  ld bc,3
  ldir

PreStep_loop:
  push bc


; struct Vec2 r1 = diffVec2(c->position, a->body1->position);
  
  push iy
  pop hl
  ld de,Contact_position
  add hl,de
  ld de,diffVec2_a
  ld bc,Vec2
  ldir

  ld de,Body_position  
  ld l,(ix+Arbiter_body1)
  ld h,(ix+Arbiter_body1+1)
  add hl,de
  ld de,diffVec2_b
  ld bc,Vec2
  ldir  
  
  call diffVec2
  
  ld de,PreStep_r1
  ld hl,diffVec2_res
  ld bc,Vec2
  ldir
  
; struct Vec2 r2 = diffVec2(c->position, a->body2->position);
  
  ld de,Body_position  
  ld l,(ix+Arbiter_body2)
  ld h,(ix+Arbiter_body2+1)
  add hl,de
  ld de,diffVec2_b
  ld bc,Vec2
  ldir  
  
  call diffVec2
  
  ld de,PreStep_r2
  ld hl,diffVec2_res
  ld bc,Vec2
  ldir

; float rn1 = Dot(r1, c->normal);
; float rn2 = Dot(r2, c->normal);

  ld de,Dot_a
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir

  push iy  ;  ld hl,iy+Contact_normal
  pop hl
  ld de,Contact_normal
  add hl,de  
  ld de,Dot_b
  ld bc,Vec2
  ldir
  
  call Dot

  push ix
  ld ix,PreStep_rn1
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld de,Dot_a
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  call Dot

  ld ix,PreStep_rn2
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix
  
; float kNormal = a->body1->invMass + a->body2->invMass;

  push ix
  ld ix,PreStep_b1invM
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,PreStep_b2invM
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
    
  call f24add
  
  ld ix,kNormal
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix
  
  ;a->body1->invI * (Dot(r1, r1) - rn1 * rn1)
  
  ld de,Dot_a
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir
  
  ld de,Dot_b
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir
  
  call Dot
  
  push ix
  ld ix,PreStep_rn1
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24mul

  push hl ; AHL->CDE
  pop de
  ld c,a

  push ix ; a
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24sub  
  
  ld ix,PreStep_b1invI
  ld c,(ix+0)  
  ld d,(ix+1)  
  ld e,(ix+2) 
  pop ix
  
  call f24mul
  
  push af
  push hl

; a->body2->invI * (Dot(r2, r2) - rn2 * rn2)  

  ld de,Dot_a
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  ld de,Dot_b
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  call Dot

  push ix  
  ld ix,PreStep_rn2
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24mul

  push hl ; AHL -> CDE
  pop de
  ld c,a

  push ix  
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24sub  

  ld ix,PreStep_b2invI
  ld c,(ix+Body_invI)  
  ld d,(ix+Body_invI+1)  
  ld e,(ix+Body_invI+2) 
  pop ix

  call f24mul

  pop de
  pop bc  
  ld c,b

  call f24add
  
  push ix
  ld ix,kNormal
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)

  call f24add

  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix

;		c->massNormal = 1.0f / kNormal;

  ld a,$3F  ; 1.0
  ld h,0
  ld l,0

  push ix  
  ld ix,kNormal
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24div
  
  ld (iy+Contact_massNormal),a
  ld (iy+Contact_massNormal+1),h
  ld (iy+Contact_massNormal+2),l
  
;		struct Vec2 tangent = Crossvs(c->normal, 1.0f);

  push iy   ; ld hl,iy+Contact_normal
  pop hl
  ld de,Contact_normal
  add hl,de  
  ld de,Crossvs_a
  ld bc,Vec2
  ldir

  push ix
  ld ix,Crossvs_s
  ld (ix+0),$3F
  ld (ix+1),0
  ld (ix+2),1
  pop ix
  
  call Crossvs
  
  ld de,PreStep_tangent
  ld hl,Crossvs_res
  ld bc,Vec2
  ldir
  
; 		float rt1 = Dot(r1, tangent);
;		float rt2 = Dot(r2, tangent);

  ld de,Dot_a
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir

  ld de,Dot_b
  ld hl,PreStep_tangent
  ld bc,Vec2
  ldir
  
  call Dot

  ld de,PreStep_rt1
  ld hl,Dot_res
  ld bc,3
  ldir
  
  ld de,Dot_a
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  call Dot

  ld de,PreStep_rt2
  ld hl,Dot_res
  ld bc,3
  ldir
  
  ; float kTangent = a->body1->invMass + a->body2->invMass;

  push ix  
  ld ix,PreStep_b1invM
  ld a,(ix+Body_invMass)
  ld h,(ix+Body_invMass+1)
  ld l,(ix+Body_invMass+2)

  ld ix,PreStep_b2invM
  ld c,(ix+Body_invMass)
  ld d,(ix+Body_invMass+1)
  ld e,(ix+Body_invMass+2)
  
  call f24add
  
  ld ix,kTangent
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix
  
  ;a->body1->invI * (Dot(r1, r1) - rt1 * rt1)
  
  ld de,Dot_a
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir
  
  ld de,Dot_b
  ld hl,PreStep_r1
  ld bc,Vec2
  ldir
  
  call Dot

  push ix  
  ld ix,PreStep_rt1
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  pop ix

  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24mul

  push hl ; AHL->CDE
  pop de
  ld c,a

  push ix  
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  pop ix

  call f24sub  

  push ix  
  ld ix,PreStep_b1invI
  ld c,(ix+0)  
  ld d,(ix+1)  
  ld e,(ix+2) 
  pop ix
  
  call f24mul
  
  push af
  push hl

; a->body2->invI * (Dot(r2, r2) - rt2 * rt2)  

  ld de,Dot_a
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  ld de,Dot_b
  ld hl,PreStep_r2
  ld bc,Vec2
  ldir
  
  call Dot

  push ix  
  ld ix,PreStep_rt2
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24mul

  push hl ; AHL -> CDE
  pop de
  ld c,a

  push ix  
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  call f24sub  
  
  ld ix,PreStep_b2invI
  ld c,(ix+0)  
  ld d,(ix+1)  
  ld e,(ix+2) 
  pop ix

  call f24mul

  pop de
  pop bc  
  ld c,b

  call f24add

  push ix  
  ld ix,kTangent
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)

  call f24add

  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix
  
;		c->massTangent = 1.0f / kTangent;

  ld a,$3F  ; 1.0
  ld h,0
  ld l,0

  push ix  
  ld ix,kTangent
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24div
  
  ld (iy+Contact_massTangent),a
  ld (iy+Contact_massTangent+1),h
  ld (iy+Contact_massTangent+2),l
  
; 		c->bias = -k_biasFactor * inv_dt * Min(0.0f, c->separation + k_allowedPenetration);


  ld a,0
  ld (Min_a),a
  ld (Min_a+1),a
  ld (Min_a+2),a

  ld a,(iy+Contact_separation)
  ld h,(iy+Contact_separation+1)
  ld l,(iy+Contact_separation+2)
  
  ld c, ;0.01f
  ld d,
  ld e,
  
  call f24add
  
  push ix
  ld ix,Min_b
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  
  call Min
  
  ld ix,PreStep_inv_dt
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+1)
  pop ix
  
  call f24mul
  
  ld c, ; 0.2f biasfactor
  
  call f24mul
  call f24neg
  
  ld (iy+Contact_bias),a
  ld (iy+Contact_bias+1),h
  ld (iy+Contact_bias+2),l
  
; struct Vec2 P = sumVec2(scaledVec2(c->Pn, c->normal), scaledVec2(c->Pt, tangent));

  push iy
  pop hl
  ld de,Contact_Pn
  add hl,de
  ld de,scaledVec2_s
  ld bc,3
  ldir
  
  push iy
  pop hl
  ld de,Contact_normal
  add hl,de
  ld de,scaledVec2_a
  ld bc,Vec2
  ldir

  call scaledVec2  
  
  ld de,sumVec2_a
  ld hl,scaledVec2_res
  ld bc,Vec2
  ldir
  
  push iy
  pop hl
  ld de,Contact_Pt
  add hl,de
  ld de,scaledVec2_s
  ld bc,3
  ldir
  
  push iy
  pop hl
  ld de,Contact_tangent
  add hl,de
  ld de,scaledVec2_a
  ld bc,Vec2
  ldir

  call scaledVec2  

  ld de,sumVec2_b
  ld hl,scaledVec2_res
  ld bc,Vec2
  ldir

  call sumVec2
  
  ld de,PreStep_P
  ld hl,sumVec2_res
  ld bc,Vec2
  ldir

; subfromVec2(&a->body1->velocity, scaledVec2(a->body1->invMass, P));

  ld hl,PreStep_b1invI
  ld de,scaledVec2_s
  ld bc,3
  ldir

  ld de,scaledVec2_a
  ld hl,PreStep_P
  ld bc,Vec2
  ldir
  
  call scaledVec2
  
  ld hl,scaledVec2_res
  ld de,subfromVec2_other
  ld bc,Vec2
  ldir
  
  ld l,(ix+Arbiter_body1)
  ld h,(ix+Arbiter_body1+1)
  ld de,Body_velocity
  add hl,de
  
  push ix

  push hl
  pop ix  ; ix vec to be subtracted from
  
  call subfromVec2

  pop ix  
  
;  a->body1->angularVelocity -= a->body1->invI * Crossvv(r1, P);

  ld de,Crossvv_a
  ld hl,PreStep_r1
  ld bc,Vec2
  
  ld de,Crossvv_b
  ld hl,PreStep_P
  ld bc,Vec2

  call Crossvv

  ld ix,Crossvv_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,PreStep_b1invI
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)

  call f24mul  
  
  push hl
  pop de
  ld c,a

  push ix  
  ld l,(ix+Arbiter_body1)
  ld h,(ix+Arbiter_body1+1)
  add hl,Body_angularVelocity
  push hl
  pop ix

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  call f24sub
  
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix

; addtoVec2(&a->body2->velocity, scaledVec2(a->body2->invMass, P));

  ld hl,PreStep_b2invI
  ld de,scaledVec2_s
  ld bc,3
  ldir

  ld de,scaledVec2_a
  ld hl,PreStep_P
  ld bc,Vec2
  ldir
  
  call scaledVec2
  
  ld hl,scaledVec2_res
  ld de,subfromVec2_other
  ld bc,Vec2
  ldir
  
  ld l,(ix+Arbiter_body2)
  ld h,(ix+Arbiter_body2+1)
  ld de,Body_velocity
  add hl,de
  
  push ix

  push hl
  pop ix  ; ix vec to be subtracted from
  
  call addtoVec2

  pop ix  

;  a->body2->angularVelocity += a->body2->invI * Crossvv(r2, P);

  ld de,Crossvv_a
  ld hl,PreStep_r2
  ld bc,Vec2
  
  ld de,Crossvv_b
  ld hl,PreStep_P
  ld bc,Vec2

  call Crossvv

  ld ix,Crossvv_res
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,PreStep_b2invI
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)

  call f24mul  
  
  push hl
  pop de
  ld c,a

  push ix  
  ld l,(ix+Arbiter_body2)
  ld h,(ix+Arbiter_body2+1)
  add hl,Body_angularVelocity

  push hl
  pop ix

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  call f24add
  
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix
  
  ; end of loop
  add iy,Contact
  pop bc
  djnz PreStep_loop

PreStep_break:

  pop iy
  pop ix

  ret

; --------------------------------------------------------------  
;  void ApplyImpulse(struct Arbiter *a)
; ix = arbiter a
; --------------------------------------------------------------  

ApplyImpulse_b1: ds 2
ApplyImpulse_b2: ds 2
ApplyImpulse_dv: ds Vec2
ApplyImpulse_vn: ds 3
ApplyImpulse_dPn: ds 3
ApplyImpulse:
  push ix
  pop hl
  ld de,ArbiterKey_body1
  add hl,de
  ld (ApplyImpulse_b1),hl

  push ix
  pop hl
  ld de,ArbiterKey_body2
  add hl,de
  ld (ApplyImpulse_b2),hl

  ld a,(ix+Arbiter_numContacts)
  ld b,a

ApplyImpulse_loop:

  push ix
  pop iy
  ld de,Arbiter_contacts
  add iy,de  ; c

;		c->r1 = diffVec2(c->position, b1->position);

  push iy
  pop hl
  ld de,Contact_position
  add hl,de
  ld de,diffVec2_a
  ld bc,Vec2
  ldir
  
  ld hl,(ApplyImpulse_b1)
  ld de,Body_position
  add hl,de
  ld de,diffVec2_b
  ld bc,Vec2
  ldir
  
  call diffVec2
  
  push iy
  ld de,Contact_r1
  add iy,de
  push iy
  pop de
  ld hl,diffVec2_res
  ld bc,Vec2
  ldir
  pop iy

;		c->r2 = diffVec2(c->position, b2->position);
  
  ld hl,(ApplyImpulse_b2)
  ld de,Body_position
  add hl,de
  ld de,diffVec2_b
  ld bc,Vec2
  ldir
  
  call diffVec2
  
  push iy
  ld de,Contact_r2
  add iy,de
  push iy
  pop de
  ld hl,diffVec2_res
  ld bc,Vec2
  ldir
  pop iy
  
; sumVec2(b2->velocity, Crosssv(b2->angularVelocity, c->r2))

  ld hl,(ApplyImpulse_b2)
  ld de,Body_angularVelocity
  add hl,de
  ld de,Crosssv_s
  ld bc,3
  ldir

  ld de,Crosssv_a
  push iy
  pop hl
  ld de,Contact_r2
  add hl,de
  ld bc,Vec2
  ldir

  call Crosssv  
  
  ld hl,(ApplyImpulse_b2)
  ld de,Body_angularVelocity
  add hl,de  
  ld de,sumVec2_a
  ld bc,Vec2
  ldir
  
  ld hl,Crosssv_res
  ld de,sumVec2_b
  ld bc,Vec2
  call sumVec2
  
  ld de,diffVec2_a
  ld hl,sumVec2_res
  ld bc,Vec2
  ldir
  
 ; sumVec2(b1->velocity, Crosssv(b1->angularVelocity, c->r1)));
 
  ld hl,(ApplyImpulse_b1)
  ld de,Body_angularVelocity
  add hl,de
  ld de,Crosssv_s
  ld bc,3
  ldir

  ld de,Crosssv_a
  push iy
  pop hl
  ld de,Contact_r1
  add hl,de
  ld bc,Vec2
  ldir

  call Crosssv  
  
  ld hl,(ApplyImpulse_b1)
  ld de,Body_velocity
  add hl,de  
  ld de,sumVec2_a
  ld bc,Vec2
  ldir
  
  ld hl,Crosssv_res
  ld de,sumVec2_b
  ld bc,Vec2
  call sumVec2
  
  ld de,diffVec2_b
  ld hl,sumVec2_res
  ld bc,Vec2
  ldir
    
  call diffVec2 

  ld de,ApplyImpulse_dv
  ld hl,diffVec2_res
  ld bc,Vec2
  ldir  
  
  ;		float vn = Dot(dv, c->normal);

  ld de,Dot_a
  ld hl,ApplyImpulse_dv
  ld bc,Vec2
  ldir
  
  ; ld hl,iy+Contact_normal
  ld de,Contact_normal
  push iy
  pop hl
  add hl,de
  ld de,Dot_b
  ld bc,Vec2
  ldir

  ld de,ApplyImpulse_vn
  ld hl,Dot_res
  ld bc,3
  ldir

;		float dPn = c->massNormal * (-vn + c->bias);

  push ix
  ld ix,ApplyImpulse_vn
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+1)
  pop ix
  
  call f24neg
  
  ld c,(iy+Contact_bias)
  ld d,(iy+Contact_bias+1)
  ld e,(iy+Contact_bias+2)

  call f24add
    
  ld c,(iy+Contact_massNormal+0)
  ld d,(iy+Contact_massNormal+1)
  ld e,(iy+Contact_massNormal+2)

  call f24mul

  push ix
  ld ix,ApplyImpulse_dPn
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix  

  ld a,(iy+Contact_Pn) ; Pn0
  ld h,(iy+Contact_Pn+1)
  ld l,(iy+Contact_Pn+2)

  push af
  push hl

  ld ix,ApplyImpulse_dPn
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24add

  ld ix,Max_a
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld (Max_b),0
  ld (Max_b+1),0
  ld (Max_b+2),0
  
  call Max
  
  ld a,(Max_res+0)
  ld h,(Max_res+1)
  ld l,(Max_res+2)
  
  ld (iy+Contact_Pn),a
  ld (iy+Contact_Pn+1),h
  ld (iy+Contact_Pn+2),l

  pop de
  pop bc
  ld c,a
      
  call f24diff

  push ix
  ld ix,ApplyImpulse_dPn
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix  
      
  ; end of loop
  
  add iy,Contact
  djnz ApplyImpulse_loop

  ret
  
; ----------------------------------------------------------------
; void addtoVec2(struct Vec2 *vec, struct Vec2 other)
; vec is passed in by ix, other by value
; ----------------------------------------------------------------

addtoVec2_other: ds Vec2
addtoVec2:
  
  ld hl,addtoVec2_other
  ld c,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld e,(hl)

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24add

  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld hl,addtoVec2_other+3
  ld c,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld e,(hl)

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  call f24add

  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  ret

; ----------------------------------------------------------------
; void subfromVec2(struct Vec2 *vec, struct Vec2 other)
; vec is passed in by ix, other by value
; ----------------------------------------------------------------

subfromVec2_other: ds Vec2
subfromVec2:
  
  ld hl,subfromVec2_other
  ld c,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld e,(hl)

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24sub

  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld hl,subfromVec2_other+3
  ld c,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld e,(hl)

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  call f24sub

  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  ret    

; ----------------------------------------------------------------
; struct Vec2 minusVec2(struct Vec2 v)
; ----------------------------------------------------------------

minusVec2_v: ds Vec2
minusVec2_res: ds Vec2
minusVec2:
  push ix
  push iy

  ld ix,minusVec2_v
  ld iy,minusVec2_res

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24neg

  ld (iy+0),a
  ld (iy+1),h
  ld (iy+2),l

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  call f24neg

  ld (iy+3),a
  ld (iy+4),h
  ld (iy+5),l
  
  pop iy
  pop ix
  ret  

; ----------------------------------------------------------------
; void scaleVec2(struct Vec2 *vec, float a);
; IX = vec
; ----------------------------------------------------------------

scaleVec2_a: ds 3
scaleVec2:
  push iy

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld iy,scaleVec2_a
  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24mul  ; destroys CDE

  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24mul

  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  
  pop iy
  ret

; ----------------------------------------------------------------
; struct Vec2 scaledVec2(float s, struct Vec2 v);
; ----------------------------------------------------------------

scaledVec2_s: ds 3
scaledVec2_v: ds Vec2
scaledVec2_res: ds Vec2
scaledVec2:

  push ix
  push iy
  
  ld ix,scaledVec2_s
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld iy,scaledVec2_v
  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24mul

  push ix
  ld ix,scaledVec2_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l   
  pop ix

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(iy+3)
  ld d,(iy+4)
  ld e,(iy+5)

  call f24mul

  ld ix,scaledVec2_res
  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  
  pop iy
  pop ix
  ret
   
; ----------------------------------------------------------------
; struct Vec2 sumVec2(struct Vec2 a, struct Vec2 b);
; ----------------------------------------------------------------

sumVec2_a: ds Vec2
sumVec2_b: ds Vec2
sumVec2_res: ds Vec2
sumVec2:

  push ix
  push iy

  ld ix,sumVec2_a
  ld iy,sumVec2_b

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24add

  push ix
  ld ix,sumVec2_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  ld c,(iy+3)
  ld d,(iy+4)
  ld e,(iy+5)
  
  call f24add

  ld ix,sumVec2_res
  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  
  pop iy
  pop ix

  ret

; ----------------------------------------------------------------
; struct Vec2 diffVec2(struct Vec2 a, struct Vec2 b);
; ----------------------------------------------------------------

diffVec2_a: ds Vec2
diffVec2_b: ds Vec2
diffVec2_res: ds Vec2
diffVec2:

  push ix
  push iy
  
  ld ix,diffVec2_a
  ld iy,diffVec2_b

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24sub

  push ix
  ld ix,diffVec2_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  pop ix

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  ld c,(iy+3)
  ld d,(iy+4)
  ld e,(iy+5)
  
  call f24sub

  ld ix,diffVec2_res
  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l
  
  pop iy
  pop ix

  ret

; ----------------------------------------------------------------
; struct Mat22 Transpose(struct Mat22 mat);
; ----------------------------------------------------------------

Transpose_mat: ds Mat22
Transpose_v1: ds Vec2
Transpose_v2: ds Vec2
Transpose_res: ds Mat22

Transpose:
  ld hl,Transpose_mat
  ld de,Transpose_v1
  ld bc,3
  ldir

  ld hl,Transpose_mat+6
  ld de,Transpose_v1+3
  ld bc,3
  ldir

  ld hl,Transpose_mat+3
  ld de,Transpose_v2
  ld bc,3
  ldir

  ld hl,Transpose_mat+9
  ld de,Transpose_v2+3
  ld bc,3
  ldir
    
  ld hl,Transpose_v1
  ld de,Transpose_res
  ld bc,6
  ldir

  ld hl,Transpose_v2
  ld de,Transpose_res+6
  ld bc,6
  ldir

  ret

; ----------------------------------------------------------------
; void initMat22(struct Mat22 *mat, float angle);
; HL = mat
; ----------------------------------------------------------------

; mat pointer in HL
initMat22_angle: ds 3
initMat22_c: ds 3
initMat22_s: ds 3
initMat22_ns: ds 3
initMat22:

   push ix ; preserve
   push hl; store pointer

   ld ix,initMat22_angle
   ld a,(ix+0) ; move angle to AHL
   ld h,(ix+1)
   ld l,(ix+2)

   push af; preseve angle
   push hl
   call f24cos

   ld ix,initMat22_c; store cos(angle)
   ld (ix+0),a
   ld (ix+1),h
   ld (ix+2),l

   pop hl; recover angle
   pop af

   call f24sin

   ld ix,initMat22_s; store sin(angle)
   ld (ix+0),a
   ld (ix+1),h
   ld (ix+2),l

   call f24neg

   ld ix,initMat22_ns; store -sin(angle)
   ld (ix+0),a
   ld (ix+1),h
   ld (ix+2),l

   pop de; pointer to mat

   push de
   ld hl,initMat22_c
   ld bc,3
   ldir ; mat->col1.x = c;
   pop de

   push de
   ex de,hl
   ld de,6
   add hl,de
   ex de,hl
   ld hl,initMat22_ns
   ld bc,3
   ldir ; mat->col2.x = -s;
   pop de

   push de
   ex de,hl
   ld de,3
   add hl,de
   ex de,hl
   ld hl,initMat22_s
   ld bc,3
   ldir ; mat->col1.y = s; 
   pop de

   ex de,hl
   ld de,6+3
   add hl,de
   ex de,hl
   ld hl,initMat22_c
   ld bc,3
   ldir ; mat->col2.y = c;
   
   pop ix
   ret   

; ----------------------------------------------------------------
; struct Vec2 matmul(struct Mat22 A, struct Vec2 v);
; ----------------------------------------------------------------

matmul_A: ds Mat22
matmul_v: ds Vec2
matmul_res: ds Vec2
matmul:

   push ix
   
   ld ix,matmul_A
   ld a,(ix+0)
   ld h,(ix+1)
   ld l,(ix+2)

   ld ix,matmul_v
   ld c,(ix+0)
   ld d,(ix+1)
   ld e,(ix+2)

   call f24mul

   push af
   push hl

   ld ix,matmul_A+6
   ld a,(ix+0)
   ld h,(ix+1)
   ld l,(ix+2)

   ld ix,matmul_v+3
   ld c,(ix+0)
   ld d,(ix+1)
   ld e,(ix+2)

   call f24mul

   pop de ; AHL -> CDE
   pop bc
   ld c,b

   call f24add
   ld ix,matmul_res
   ld (ix+0),a
   ld (ix+1),h
   ld (ix+2),l

   ld ix,matmul_A+3
   ld a,(ix+0)
   ld h,(ix+1)
   ld l,(ix+2)

   ld ix,matmul_v
   ld c,(ix+0)
   ld d,(ix+1)
   ld e,(ix+2)

   call f24mul

   push af
   push hl

   ld ix,matmul_A+6+3
   ld a,(ix+0)
   ld h,(ix+1)
   ld l,(ix+2)

   ld ix,matmul_v+3
   ld c,(ix+0)
   ld d,(ix+1)
   ld e,(ix+2)

   call f24mul

   pop de
   pop bc
   ld c,b

   call f24add
   ld ix,matmul_res
   ld (ix+3),a
   ld (ix+4),h
   ld (ix+5),l
   
   pop ix
   ret

; ----------------------------------------------------------------
; struct Mat22 matmulMM(struct Mat22 A, struct Mat22 B);
; res.col1 = matmul(A, B.col1);
; res.col2 = matmul(A, B.col2);
; ----------------------------------------------------------------

matmulMM_A: ds Mat22
matmulMM_B: ds Mat22
matmulMM_res: ds Mat22
matmulMM:

   ld hl,matmulMM_A
   ld de,matmul_A
   ld bc,2*2*3
   ldir

   ld hl,matmulMM_B
   ld de,matmul_v
   ld bc,2*3
   ldir

   call matmul

   ld hl,matmul_res
   ld de,matmulMM_res
   ld bc,2*3
   ldir

   ld hl,matmulMM_B+6
   ld de,matmul_v
   ld bc,2*3
   ldir   

   call matmul

   ld de,matmulMM_res+6
   ld hl,matmul_res
   ld bc,6
   ldir

   ret

; ----------------------------------------------------------------
; float Dot(struct Vec2 a, struct Vec2 b);
; ----------------------------------------------------------------

Dot_a: ds Vec2
Dot_b: ds Vec2
Dot_res: ds 3
Dot:

  push ix
  push iy
  
  ld ix,Dot_a
  ld iy,Dot_b

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24mul

  push af
  push hl

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  ld c,(iy+3)
  ld d,(iy+4)
  ld e,(iy+5)

  call f24mul

  pop de
  pop bc

  ld c,b

  call f24add

  ld ix,Dot_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  
  pop iy
  pop ix

  ret

; float Min(float a, float b)

Min_a: ds 3
Min_b: ds 3
Min_res: ds 3
Min:

  push ix

  ld ix,Min_a
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,Min_b
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24cmp
  
  jr c Min_skip ; a < b

  ld (ix+0),c
  ld (ix+1),d
  ld (ix+2),e
  
  pop ix
  ret
  
Min_skip:
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  pop ix

  ret  
  
; ------------------------------------------------------------------
; struct Vec2 Absv(struct Vec2 a)
; ------------------------------------------------------------------

Absv_a: ds Vec2
Absv_res: ds Vec2
Absv:
  ld hl,Absv_a
  ld de,Absv_res
  ld bc,6
  ldir

  ld a,(Absv_res)
  and $7F
  ld (Absv_res),a

  ld a,(Absv_res+3)
  and $7F
  ld (Absv_res+3),a

  ret
  
; ------------------------------------------------------------------
; struct Mat22 AbsM(struct Mat22 A)
; ------------------------------------------------------------------

AbsM_A: ds Mat22
AbsM_res: ds Mat22
AbsM:
  ld hl,AbsM_A
  ld de,Absv_a
  ld bc,Vec2
  ldir
  
  call Absv
  
  ld hl,Absv_res
  ld de,AbsM_res
  ld bc,Vec2
  ldir
  
  ld hl,AbsM_A+Mat22_col2
  ld de,Absv_a
  ld bc,Vec2
  ldir
  
  call Absv
  
  ld hl,Absv_res
  ld de,AbsM_res+Mat22_col2
  ld bc,Vec2
  ldir
  
  ret
  
; struct Vec2 Crossvs(struct Vec2 a, float s)
Crossvs_a: ds Vec2
Crossvs_s: ds 3
Crossvs_res: ds Vec2
Crossvs:  

  push ix
  ld ix,Crossvs_s
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  ld ix,Crossvs_a
  ld c,(ix+3)
  ld d,(ix+4)
  ld e,(ix+5)
  
  call f24mul

  ld ix,Crossvs_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld ix,Crossvs_s
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  ld ix,Crossvs_a
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24mul
  call f24neg

  ld ix,Crossvs_res
  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l

  pop ix  
  ret

; struct Vec2 Crosssv(float s, struct Vec2 a)
Crosssv_s: ds 3
Crosssv_a: ds Vec2
Crosssv_res: ds Vec2
Crosssv: 
  push ix 
  ld ix,Crosssv_s
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  ld ix,Crosssv_a
  ld c,(ix+3)
  ld d,(ix+4)
  ld e,(ix+5)
  
  call f24mul
  call f24neg

  ld ix,Crosssv_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  ld ix,Crosssv_s
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
    
  ld ix,Crosssv_a
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24mul

  ld ix,Crosssv_res
  ld (ix+3),a
  ld (ix+4),h
  ld (ix+5),l

  pop ix
  ret

; ----------------------------------------------------------------
; float Crossvv(struct Vec2 a, struct Vec2 b)
; return a.x * b.y - a.y * b.x;
; ----------------------------------------------------------------

Crossvv_a: ds Vec2
Crossvv_b: ds Vec2
Crossvv_res: ds 3
Crossvv:

  push ix
  push iy
  
  ld ix,Crossvv_a
  ld iy,Crossvv_b

  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld c,(iy+3)
  ld d,(iy+4)
  ld e,(iy+5)

  call f24mul

  push af
  push hl

  ld a,(ix+3)
  ld h,(ix+4)
  ld l,(ix+5)

  ld c,(iy+0)
  ld d,(iy+1)
  ld e,(iy+2)

  call f24mul

  ld c,a
  ld d,h
  ld e,l

  pop hl
  pop af

  call f24sub

  ld ix,Crossvv_res
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  
  pop iy
  pop ix

  ret

; ------------------------------------------------------------------
; void initClipVertex(struct ClipVertex *cv)
; ------------------------------------------------------------------

initClipVertex:
  ld (ix+6),0
  ld (ix+7),0
  ld (ix+8),0  
  ld (ix+9),0
  ret

; ------------------------------------------------------------------
; void Swap(char* a, char* b)
; IX=a, IY=b
; ------------------------------------------------------------------

Swap:
  ld a,(ix+0)
  ld b,(iy+0)

  ld (iy+0),a
  ld (ix+0),b
  ret

; ------------------------------------------------------------------
; void Flip(struct Edges *fp)
; IX=fp
; ------------------------------------------------------------------

Flip:
  push ix
  push iy
  
  push ix
  pop iy
  inc iy
  inc iy
  
;  ld iy,ix+2

  call Swap

  push ix
  pop iy
  
  inc ix
  inc iy
  inc iy
  inc iy

;  ld ix,ix+1
;  ld iy,ix+3

  call Swap
  
  pop iy
  pop ix
  ret

; ------------------------------------------------------------------
; HL=base of array, A=index, DE=size of items in array in bytes
; Advance HL
; ------------------------------------------------------------------

arrayIndex:

  cp 0
  ret z

  ld b,a

arrayIndex_loop:
  add hl,de
  djnz arrayIndex_loop  

  ret

; ------------------------------------------------------------------
; int ClipSegmentToLine(struct ClipVertex vOut[2], struct ClipVertex vIn[2],
;                       struct Vec2 normal, float offset, char clipEdge)
; ix points to vOut, iy points to vIn
; ------------------------------------------------------------------

ClipSegmentToLine_normal: ds Vec2
ClipSegmentToLine_offset: ds 3
ClipSegmentToLine_clipEdge: ds 1

ClipSegmentToLine_distance0: ds 3
ClipSegmentToLine_distance1: ds 3
ClipSegmentToLine_interp: ds 3
ClipSegmentToLine:
  ld a,0 ; numOut
  push af

  ; float distance0 = Dot(normal, vIn[0].v) - offset
  ; if (distance0 <= 0.0f) vOut[numOut++] = vIn[0]

  ld hl,ClipSegmentToLine_normal
  ld de,Dot_a
  ld bc,Vec2
  ldir

  push iy
  pop hl
  ld de,Dot_b
  ld bc,Vec2
  ldir

  call Dot

  push ix
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)  
  ld l,(ix+2)

  ld ix,ClipSegmentToLine_offset

  ld c,(ix+0)
  ld d,(ix+1)  
  ld e,(ix+2)

  call f24sub

  ld ix,ClipSegmentToLine_distance0
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  pop ix

;	if (distance0 <= 0.0f) vOut[numOut++] = vIn[0]

  ld c,0; 0.0f
  ld d,0
  ld e,0

  call f24cmp

  jr z,ClipSegmentToLine2; jump if distance0 > 0.0f
  jr nc,ClipSegmentToLine1
ClipSegmentToLine2:

  pop af
  
  push ix
  pop hl ; vOut[numOut++] = vIn[0];

  ld de,ClipVertex  
  call arrayIndex ; hl = vOut[numOut]

  ex de,hl 
  push iy          ; vIn
  pop hl
  ld bc,ClipVertex
  ldir  
  inc a ; numOut++

  push af

ClipSegmentToLine1:

  ; float distance1 = Dot(normal, vIn[1].v) - offset
  ; if (distance1 <= 0.0f) vOut[numOut++] = vIn[1]

;  ld hl,ClipSegmentToLine_normal
;  ld de,Dot_a
;  ld bc,Vec2
;  ldir

; Dot_a is still in place

  push iy
  pop hl
  ld bc,ClipVertex
  add hl,bc
  ld de,Dot_b
  ld bc,Vec2
  ldir

  call Dot

  push ix
  ld ix,Dot_res
  ld a,(ix+0)
  ld h,(ix+1)  
  ld l,(ix+2)

  ld ix,ClipSegmentToLine_offset
  ld c,(ix+0)
  ld d,(ix+1)  
  ld e,(ix+2)

  call f24sub

  ld ix,ClipSegmentToLine_distance1
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l

  pop ix

;	if (distance1 <= 0.0f) vOut[numOut++] = vIn[1]

  ld c,0; 0.0f
  ld d,0
  ld e,0

  call f24cmp

  jr z,ClipSegmentToLine3; jump if distance1 > 0.0f
  jr nc,ClipSegmentToLine4
ClipSegmentToLine3:

  pop af
  
  push ix
  pop hl ; vOut[numOut++] = vIn[1];

  ld de,ClipVertex  
  call arrayIndex ; hl = vOut[numOut]

  ex de,hl 
  push iy
  pop hl
  ld bc,ClipVertex
  add hl,bc
  ldir  
  inc a ; numOut++

  push af

ClipSegmentToLine4:

; if (distance0 * distance1 < 0.0f)

  push ix
  ld ix,ClipSegmentToLine_distance0
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  
  ld ix,ClipSegmentToLine_distance1
  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  pop ix
  
  call f24mul
  
  ld c,0
  ld d,0
  ld e,0
  
  call f24cmp
  
  jp nc, ClipSegmentToLine5; jump if AHL >= 0  

  push ix
  ld ix,ClipSegmentToLine_distance0
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  ld ix,ClipSegmentToLine_distance1

  ld c,(ix+0)
  ld d,(ix+1)
  ld e,(ix+2)
  
  call f24sub
    
  ld c,a
  ld d,h
  ld e,l
  
  ld ix,ClipSegmentToLine_distance0
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)

  call f24div

  ld ix,ClipSegmentToLine_interp
  
  ld (ix+0),a
  ld (ix+1),h
  ld (ix+2),l
  
  pop ix
  
; vOut[numOut].v = sumVec2(vIn[0].v, scaledVec2(interp , diffVec2(vIn[1].v, vIn[0].v)));

  push iy ; vIn
  pop hl
  
  ld bc,ClipVertex
  add hl,bc
  
  ld de,diffVec2_a
  ld bc,Vec2
  ldir
  
  push iy ; vIn
  pop hl
  
  ld de,diffVec2_b
  ld bc,Vec2
  ldir
  
  call diffVec2
  
  ld hl,diffVec2_res
  ld de,scaledVec2_v
  ld bc,Vec2
  ldir
  
  ld hl,ClipSegmentToLine_interp
  ld de,scaledVec2_s
  ld bc,3
  ldir
  
  call scaledVec2
  
  ld hl,scaledVec2_res
  ld de,sumVec2_b
  ld bc,Vec2
  ldir
  
  push iy
  pop hl
  
  ld de,sumVec2_a
  ld bc,Vec2
  ldir
  
  call sumVec2
  
  push ix
  pop hl
  pop af
  ld de,ClipVertex
  call arrayIndex
  push af
  
  ex de,hl
  ld hl,sumVec2_res
  ld bc,Vec2
  ldir
  
;		if (distance0 > 0.0f)

  push ix
  ld ix,ClipSegmentToLine_distance0  
  ld a,(ix+0)
  ld h,(ix+1)
  ld l,(ix+2)
  pop ix
  
  ld c,0
  ld d,0
  ld e,0
  
  call f24cmp
  
  jr c,ClipSegmentToLineElse; jump if distance0 <= 0
  jr z,ClipSegmentToLineElse
  
; vOut[numOut].fp = vIn[0].fp
; vOut[numOut].fp.inEdge1 = clipEdge
; vOut[numOut].fp.inEdge2 = NO_EDGE;

  push ix
  pop hl

  pop af
  ld de,ClipVertex
  call arrayIndex
  push af
  
  ld bc,ClipVertex_fp
  add hl,bc

  push hl; store pointer vOut[numOut].fp
  
  ex de,hl
  
  push iy
  pop hl
  ld bc,ClipVertex_fp
  add hl,bc
  
  ld bc,Edges
  ldir
  
  pop hl ; get pointer
  push hl ; store pointer
  ld bc,Edges_inEdge1
  add hl,bc
  
  ld a,(ClipSegmentToLine_clipEdge)
  ld (hl),a
  
  pop hl ; get pointer
  ld bc,Edges_inEdge2
  add hl,bc
  
  ld (hl),NO_EDGE
  
  jr ClipSegmentToLineEndif
  
ClipSegmentToLineElse:

; vOut[numOut].fp = vIn[1].fp
; vOut[numOut].fp.inEdge1 = clipEdge
; vOut[numOut].fp.inEdge2 = NO_EDGE;

  push ix
  pop hl

  pop af
  ld de,ClipVertex
  call arrayIndex
  push af
  
  ld bc,ClipVertex_fp
  add hl,bc

  push hl; store pointer vOut[numOut].fp
  
  ex de,hl
  
  push iy
  pop hl
  ld bc,ClipVertex_fp+ClipVertex
  add hl,bc
  
  ld bc,Edges
  ldir
  
  pop hl ; get pointer
  push hl ; store pointer
  ld bc,Edges_outEdge1
  add hl,bc
  
  ld a,(ClipSegmentToLine_clipEdge)
  ld (hl),a
  
  pop hl ; get pointer
  ld bc,Edges_outEdge2
  add hl,bc
  
  ld (hl),NO_EDGE
  
ClipSegmentToLineEndif

  pop af
  inc a
  push af
  
ClipSegmentToLine5:
  
  pop af; numOut in a
  ret

; ----------------------------------------------------------------
; void ComputeIncidentEdge(struct ClipVertex c[2], struct Vec2 h, struct Vec2 pos, struct Mat22 Rot, struct Vec2 normal)
; IX = c
; ----------------------------------------------------------------

ComputeIncidentEdge_h: ds Vec2
ComputeIncidentEdge_pos: ds Vec2
ComputeIncidentEdge_Rot: ds Mat22
ComputeIncidentEdge_normal: ds Vec2

ComputeIncidentEdge_n: ds Vec2
ComputeIncidentEdge_nAbs: ds Vec2
ComputeIncidentEdge_RotT: ds Mat22
ComputeIncidentEdge:

; RotT = Transpose(Rot)

    push iy

;    push ix    
;    ld ix,ComputeIncidentEdge_h
;    call writeVec2
;    pop ix

    ld hl,ComputeIncidentEdge_Rot 
    ld de,Transpose_mat
    ld bc,12
    ldir
    
    call Transpose

    ld hl,Transpose_res
    ld de,ComputeIncidentEdge_RotT
    ld bc,12
    ldir

; n = minusVec2(matmul(RotT, normal))

    ld hl,ComputeIncidentEdge_RotT 
    ld de,matmul_A
    ld bc,2*2*3
    ldir

    ld hl,ComputeIncidentEdge_normal
    ld de,matmul_v
    ld bc,Vec2
    ldir

    call matmul

    ld hl,matmul_res
    ld de,minusVec2_v
    ld bc,6
    ldir

    call minusVec2

    ld hl,minusVec2_res
    ld de,ComputeIncidentEdge_n
    ld bc,2*3
    ldir

; nAbs = Absv(n)

    ld hl,ComputeIncidentEdge_n 
    ld de,Absv_a
    ld bc,Vec2
    ldir

    call Absv
    
    ld hl,Absv_res
    ld de,ComputeIncidentEdge_nAbs
    ld bc,Vec2
    ldir

;--------------------------------------------------------
; if (nAbs.x > nAbs.y)
;--------------------------------------------------------

    ld iy,ComputeIncidentEdge_nAbs

    ld a,(iy+0)
    ld h,(iy+1)
    ld l,(iy+2)

    ld c,(iy+3)
    ld d,(iy+4)
    ld e,(iy+5)

    call f24cmp

    jp c, ComputeIncidentEdge_else ; jump if nAbs.x <= nAbs.y
    jp z, ComputeIncidentEdge_else

; if (n.x > 0.0f)

    ld iy,ComputeIncidentEdge_n
    ld a,(iy+0)   
    ld h,(iy+1)
    ld l,(iy+2)

    ld c,0
    ld d,0
    ld e,0

    call f24cmp

    jr c, ComputeIncidentEdge_else1; n.x <= 0.0f
    jr z, ComputeIncidentEdge_else1; n.x <= 0.0f

    push ix
    pop de
    ld hl,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld a,(ix+Vec2_y)
    call f24neg
    ld (ix+Vec2_y),a

    ld (ix+ClipVertex_fp+Edges_inEdge2),EDGE3
    ld (ix+ClipVertex_fp+Edges_outEdge2),EDGE4

    push ix
    pop hl
    ld bc,ClipVertex
    add hl,bc
    ex de,hl
    ld hl,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld (ix+ClipVertex + ClipVertex_fp + Edges_inEdge2),EDGE4
    ld (ix+ClipVertex + ClipVertex_fp + Edges_outEdge2),EDGE1
    jr ComputeIncidentEdge_endif1

ComputeIncidentEdge_else1:
    push ix
    pop de
    ld hl,ComputeIncidentEdge_h
    ld bc,6
    ldir

    ld a,(ix+0)
    call f24neg
    ld (ix+0),a

    ld (ix+ClipVertex_fp+Edges_inEdge2),EDGE1
    ld (ix+ClipVertex_fp+Edges_outEdge2),EDGE2

    push ix
    pop hl
    ld de,ClipVertex
    add hl,de
    ex de,hl
    ld hl,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld a,(ix+ClipVertex) ; only a needs to be negated in AHL
    call f24neg
    ld (ix+ClipVertex),a

    ld a,(ix+ClipVertex+3)
    call f24neg
    ld (ix+ClipVertex+3),a

    ld (ix+ClipVertex + ClipVertex_fp + Edges_inEdge2),EDGE2
    ld (ix+ClipVertex + ClipVertex_fp + Edges_outEdge2),EDGE3
ComputeIncidentEdge_endif1:

    jp ComputeIncidentEdge_endif

;---------------------------------------------------------
; major else
;---------------------------------------------------------

ComputeIncidentEdge_else:

    ld iy,ComputeIncidentEdge_n
    ld a,(iy+3)
    ld h,(iy+4)
    ld l,(iy+5)
    
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp; skip if n.y <= 0.0
    
    jr c,ComputeIncidentEdge_else2
    jr z,ComputeIncidentEdge_else2

    ld hl,ComputeIncidentEdge_h
    push ix
    pop de
    ld bc,Vec2
    ldir
        
    ld (ix+ClipVertex_fp+Edges_inEdge2),EDGE4
    ld (ix+ClipVertex_fp+Edges_outEdge2),EDGE1
    
    push ix
    pop hl
    ld de,ClipVertex
    add hl,de
    ex de,hl
    ld hl,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir
    
    ld a,(ix+ClipVertex)
    call f24neg
    ld (ix+ClipVertex),a
    
    ld (ix+ClipVertex+ClipVertex_fp+Edges_inEdge2),EDGE1
    ld (ix+ClipVertex+ClipVertex_fp+Edges_outEdge2),EDGE2
    jr ComputeIncidentEdge_endif
    
ComputeIncidentEdge_else2:

    ld hl,ComputeIncidentEdge_h
    push ix
    pop de
    ld bc,6
    ldir

    ld a,(ix+0)
    call f24neg
    ld (ix+0),a
    
    ld a,(ix+3)
    call f24neg
    ld (ix+3),a
    
    ld (ix+ClipVertex_fp+Edges_inEdge2),EDGE2
    ld (ix+ClipVertex_fp+Edges_outEdge2),EDGE3
    
    push ix
    pop hl
    ld de,ClipVertex
    add hl,de
    ex de,hl
    ld hl,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir
    
    ld a,(ix+ClipVertex+3)
    call f24neg
    ld (ix+ClipVertex+3),a
    
    ld (ix+ClipVertex+ClipVertex_fp+Edges_inEdge2),EDGE3
    ld (ix+ClipVertex+ClipVertex_fp+Edges_outEdge2),EDGE4
    
ComputeIncidentEdge_endif:

;-----------------------------------------------------------
; c[0].v = sumVec2(pos, matmul(Rot, c[0].v))
; c[1].v = sumVec2(pos, matmul(Rot, c[1].v))
;-----------------------------------------------------------

    ld hl,ComputeIncidentEdge_Rot
    ld de,matmul_a
    ld bc,12
    ldir

    push ix
    pop hl

    ld de,matmul_v
    ld bc,6
    ldir

    call matmul

    ld hl,ComputeIncidentEdge_pos
    ld de,sumVec2_a
    ld bc,6
    ldir

    ld hl,matmul_res
    ld de,sumVec2_b
    ld bc,6
    ldir

    call sumVec2

    push ix
    pop de
    ld hl,sumVec2_res
    ld bc,Vec2
    ldir

    ;----
    
    push ix
    pop hl
    
    ld bc,ClipVertex
    add hl,bc
    push hl ; store pointer for final copy
    ld de,matmul_v
    ld bc,Vec2
    ldir
    
    call matmul ; Rot still in place

    ld hl,matmul_res
    ld de,sumVec2_b
    ld bc,6
    ldir

    call sumVec2 ; pos still in place

    pop de ; get pointer back
    ld hl,sumVec2_res
    ld bc,Vec2
    ldir
	
	pop iy

    ret

; -----------------------------------------------------------------------------
; int Collide(struct Contact* contacts, struct Body* bodyA, struct Body* bodyB)
; hl=contact, ix=bodyA, iy=bodyB. Return in a
;-----------------------------------------------------------------------------

Collide_hA: ds Vec2
Collide_hB: ds Vec2
Collide_RotA: ds 12
Collide_RotB: ds 12
Collide_posA: ds Vec2
Collide_posB: ds Vec2
Collide_RotAT ds Mat22
Collide_RotBT ds Mat22
Collide_a1 ds Vec2
Collide_b1 ds Vec2
Collide_a2 ds Vec2
Collide_b2 ds Vec2
Collide_dp ds Vec2
Collide_dA ds Vec2
Collide_dB ds Vec2
Collide_C ds Mat22
Collide_absC ds Mat22
Collide_absCT ds Mat22
Collide_faceA ds Vec2
Collide_faceB ds Vec2
Collide_axis ds 1
Collide_separation ds 3
Collide_normal ds Vec2
Collide_frontNormal ds Vec2
Collide_sideNormal ds Vec2
Collide_incidentEdge ds ClipVertex*2
Collide_front ds 3
Collide_negSide ds 3
Collide_posSide ds 3
Collide_negEdge ds 1
Collide_posEdge ds 1
Collide_side ds 3
Collide_clipPoints1 ds ClipVertex*2
Collide_clipPoints2 ds ClipVertex*2
Collide_numContacts ds 1
Collide_contacts ds 2

Collide:

    push ix
	push iy
    
    ld (Collide_contacts),hl

;	struct Vec2 hA = scaledVec2(0.5f, bodyA->width)
    push ix
    pop hl
    ld bc,Body_width
    add hl,bc
    ld de,scaledVec2_v
    ld bc,Vec2
    ldir

; .db $00,$00,$3E  ;0.5

    push ix
    ld ix,scaledVec2_s
    ld (ix+0),$3E ; 0.5
    ld (ix+1),0
    ld (ix+2),0
    pop ix

    call scaledVec2

; debug code
;    push ix    
;    ld ix,scaledVec2_res
;    call writeVec2
;    pop ix
;    pop iy
;    pop ix
;    ret
    
    ld hl,scaledVec2_res
    ld de,Collide_hA
    ld bc,Vec2
    ldir

;	struct Vec2 hB = scaledVec2(0.5f, bodyB->width)
    push iy
    pop hl
    ld bc,Body_width
    add hl,bc
    ld de,scaledVec2_v
    ld bc,Vec2
    ldir

; already done
;    push ix
;    ld ix,scaledVec2_a
;    ld (ix+0),$3E
;    ld (ix+1),0
;    ld (ix+2),0
;    pop ix

    call scaledVec2

    ld hl,scaledVec2_res
    ld de,Collide_hB
    ld bc,Vec2
    ldir
    
;	struct Vec2 posA = bodyA->position
;	struct Vec2 posB = bodyB->position

    push ix
    pop hl
    ld bc,Body_position
    add hl,bc
    ld de,Collide_posA
    ld bc,Vec2
    ldir

    push iy
    pop hl
    ld bc,Body_position
    add hl,bc
    ld de,Collide_posB
    ld bc,Vec2
    ldir
    
;  initMat22(&RotA, bodyA->rotation); initMat22(&RotB, bodyB->rotation)
    
    push ix
    pop hl
    
    ld bc,Body_rotation
    add hl,bc
    
    ld de,initMat22_angle
    ld bc,3
    ldir
    
    ld hl,Collide_RotA
    call initMat22    

    push iy
    pop hl
    
    ld bc,Body_rotation
    add hl,bc
    
    ld de,initMat22_angle
    ld bc,3
    ldir
    
    ld hl,Collide_RotB
    call initMat22

; bodyA and bodyB are not used again so we can use ix, iy freely!
; HL = contacts still on stack    
    
;   struct Mat22 RotAT = Transpose(RotA)
;	struct Mat22 RotBT = Transpose(RotB)

    ld hl,Collide_RotA
    ld de,Transpose_mat
    ld bc,12
    ldir
    
    call Transpose
    
    ld hl,Transpose_res
    ld de,Collide_RotAT
    ld bc,12
    ldir

    ld hl,Collide_RotB
    ld de,Transpose_mat
    ld bc,12
    ldir
    
    call Transpose
    
    ld hl,Transpose_res
    ld de,Collide_RotBT
    ld bc,12
    ldir
    
;   struct Vec2 a1 = RotA.col1, a2 = RotA.col2
;	struct Vec2 b1 = RotB.col1, b2 = RotB.col2

    ld hl,Collide_RotA+Mat22_col1
    ld de,Collide_a1
    ld bc,Vec2
    ldir
    
    ld hl,Collide_RotA+Mat22_col2
    ld de,Collide_a2
    ld bc,Vec2
    ldir

    ld hl,Collide_RotB+Mat22_col1
    ld de,Collide_b1
    ld bc,Vec2
    ldir
    
    ld hl,Collide_RotB+Mat22_col2
    ld de,Collide_b2
    ld bc,Vec2
    ldir

;	struct Vec2 dp = diffVec2(posB, posA);

    ld hl,Collide_posB
    ld de,diffVec2_a
    ld bc,Vec2
    ldir

    ld hl,Collide_posA
    ld de,diffVec2_b
    ld bc,Vec2
    ldir
    
    call diffVec2
    
    ld hl,diffVec2_res
    ld de,Collide_dp
    ld bc,Vec2
    ldir
    
;	struct Vec2 dA = matmul(RotAT, dp)
;	struct Vec2 dB = matmul(RotBT, dp)

    ld hl,Collide_dp
    ld de,matmul_v
    ld bc,Vec2
    ldir
    
    ld hl,Collide_RotAT
    ld de,matmul_A
    ld bc,12
    ldir
    
    call matmul
    
    ld hl,matmul_res
    ld de,Collide_dA
    ld bc,Vec2
    ldir
    
    ld hl,Collide_RotBT
    ld de,matmul_A
    ld bc,12
    ldir
    
    call matmul
    
    ld hl,matmul_res
    ld de,Collide_dB
    ld bc,Vec2
    ldir
    
    ;	struct Mat22 C = matmulMM(RotAT, RotB)
    
    ld hl,Collide_RotAT
    ld de,matmulMM_A
    ld bc,12
    ldir
    
    ld hl,Collide_RotB
    ld de,matmulMM_B
    ld bc,12
    ldir
    
    call matmulMM
    
    ld hl,matmulMM_res
    ld de,Collide_C
    ld bc,12
    ldir
    
;   struct Mat22 absC = AbsM(C)
;	struct Mat22 absCT = Transpose(absC)
    
    ld hl,Collide_C
    ld de,AbsM_a
    ld bc,12
    ldir
    
    call AbsM
    
    ld hl,AbsM_res
    ld de,Collide_absC
    ld bc,12
    ldir
    
    ld hl,Collide_absC
    ld de,Transpose_mat
    ld bc,12
    ldir
    
    call Transpose
    
    ld hl,Transpose_res
    ld de,Collide_absCT
    ld bc,12
    ldir
        
;	struct Vec2 faceA = diffVec2(Absv(dA), hA)
;   subfromVec2(&faceA, matmul(absC, hB))
    
    ld hl,Collide_dA
    ld de,Absv_a
    ld bc,Vec2
    ldir    
    
    call Absv
    
    ld hl,Absv_res
    ld de,diffVec2_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_hA
    ld de,diffVec2_b
    ld bc,Vec2
    ldir
    
    call diffVec2
    
    ld hl,diffVec2_res
    ld de,Collide_faceA
    ld bc,Vec2
    ldir
    
    ld ix,Collide_faceA
    ld hl,Collide_absC
    ld de,matmul_a
    ld bc,12
    ldir
    
    ld hl,Collide_hB
    ld de,matmul_v
    ld bc,Vec2
    ldir
    
    call matmul
    
    ld hl,matmul_res
    ld de,subfromVec2_other
    ld bc,Vec2
    ldir
    
    call subfromVec2
    
;	if (faceA.x > 0.0f || faceA.y > 0.0f)
;		return 0;
 
    ld ix,Collide_faceA
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    bit 7,a ; if 0 its positive
        
    ld a,0
    pop iy
    pop ix

    ret z ; return if faceA.x positive
    
    push ix
    push iy

    ld ix,Collide_faceA
    ld a,(ix+3)
    ld h,(ix+4)
    ld l,(ix+5)
    
    bit 7,a
        
    ld a,0
    pop iy
    pop ix

    ret z ; return if faceA.y positive

    push ix
    push iy
    
;	struct Vec2 faceB = diffVec2(Absv(dB), hB)
;   subfromVec2(&faceB, matmul(absCT, hA))

    ld hl,Collide_dB
    ld de,Absv_a
    ld bc,Vec2
    ldir    
    
    call Absv
    
    ld hl,Absv_res
    ld de,diffVec2_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_hB
    ld de,diffVec2_b
    ld bc,Vec2
    ldir
    
    call diffVec2
    
    ld hl,diffVec2_res
    ld de,Collide_faceB
    ld bc,Vec2
    ldir
    
    ld hl,Collide_absCT
    ld de,matmul_a
    ld bc,12
    ldir
    
    ld hl,Collide_hA
    ld de,matmul_v
    ld bc,Vec2
    ldir
    
    call matmul
    
    ld hl,matmul_res
    ld de,subfromVec2_other
    ld bc,Vec2
    ldir

    ld ix,Collide_faceB
    call subfromVec2

;	if (faceB.x > 0.0f || faceB.y > 0.0f)
;		return 0;
 
    push ix
    ld ix,Collide_faceB
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    pop ix
    
    bit 7,a
    
    ld a,0
    
    pop iy
    pop ix
    
    ret z

    push ix
    push iy

    push ix
    ld ix,Collide_faceB
    ld a,(ix+3)
    ld h,(ix+4)
    ld l,(ix+5)
    pop ix

    bit 7,a
        
    ld a,0
    pop iy
    pop ix
    ret z

    push ix
    push iy
    
;	axis = FACE_A_X
;	separation = faceA.x
;	normal = dA.x > 0.0f ? RotA.col1 : minusVec2(RotA.col1)

    ld a,FACE_A_X
    ld (Collide_axis),a

    ld hl,Collide_faceA
    ld de,Collide_separation
    ld bc,3
    ldir
    
;    LOST ix = bodyA, iy = bodyB
    ld ix,Collide_dA
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp
    jr c,Collide5
    jr z,Collide5
    
    ld hl,Collide_RotA
    jr Collide6

Collide5:    
    ld hl,Collide_RotA
    ld de,minusVec2_v
    ld bc,Vec2
    ldir

    call minusVec2
    ld hl,minusVec2_res    

Collide6:    
    ld de,Collide_normal
    ld bc,Vec2
    ldir

;	if (faceA.y > relativeTol * separation + absoluteTol * hA.y)
;	{
;		axis = FACE_A_Y
;		separation = faceA.y
;		normal = dA.y > 0.0f ? RotA.col2 : minusVec2(RotA.col2)
;	}
        
        
; .db $66,$E6,$3E  ;0.95

    ld a,$3E; 0.95 (relativeTol)
    ld h,$E6
    ld l,$66

    ld ix,Collide_separation
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24mul
    
    push af
    push hl
    
    ; .db $AE,$47,$38
    ld a,$38; 0.01 (absoluteTol)
    ld h,$47 
    ld l,$AE

    ld ix,Collide_hA
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24mul
    
    ld c,a
    ld d,h
    ld e,l
    
    pop hl
    pop af
    
    call f24add
    
    ld c,a
    ld d,h
    ld e,l
    
    ld ix,Collide_faceA
    ld a,(ix+3)
    ld h,(ix+4)
    ld l,(ix+5)
    
    call f24cmp
    
    jr c,Collide7
    jr z,Collide7
    
    ld a,FACE_A_Y
    ld (Collide_axis),a
    
    ld hl,Collide_faceA+3
    ld de,Collide_separation
    ld bc,3
    ldir
    
    ld ix,Collide_dA
    ld a,(ix+3)
    ld h,(ix+4)
    ld l,(ix+5)
    
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp
    jr c,Collide7a
    jr z,Collide7a
    
    ld hl,Collide_RotA+Mat22_col2
    jr Collide7b

Collide7a:    
    ld hl,Collide_RotA+Mat22_col2
    ld de,minusVec2_v
    ld bc,Vec2
    ldir

    call minusVec2
    ld hl,minusVec2_res    

Collide7b:    
    ld de,Collide_normal
    ld bc,Vec2
    ldir
    
Collide7:
        
;	if (faceB.x > relativeTol * separation + absoluteTol * hB.x)
;	{
;		axis = FACE_B_X
;		separation = faceB.x
;		normal = dB.x > 0.0f ? RotB.col1 : minusVec2(RotB.col1)
;	}

    ld a,$3E; 0.95 (relativeTol)
    ld h,$E6
    ld l,$66
        
    ld ix,Collide_separation
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24mul
    
    push af
    push hl

    ld a,$38; 0.01 (absoluteTol)
    ld h,$47 
    ld l,$AE
    
    ld ix,Collide_hB
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24mul
    
    ld c,a
    ld d,h
    ld e,l
    
    pop hl
    pop af
    
    call f24add
    
    ld c,a
    ld d,h
    ld e,l
    
    ld ix,Collide_faceB
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    call f24cmp
    
    jr c,Collide8
    jr z,Collide8
    
    ld a,FACE_B_X
    ld (Collide_axis),a
    
    ld hl,Collide_faceB
    ld de,Collide_separation
    ld bc,3
    ldir

    ld ix,Collide_dB
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp
    jr c,Collide8a
    jr z,Collide8a
    
    ld hl,Collide_RotB
    jr Collide8b

Collide8a:    
    ld hl,Collide_RotB
    ld de,minusVec2_v
    ld bc,Vec2
    ldir

    call minusVec2
    ld hl,minusVec2_res    

Collide8b:    
    ld de,Collide_normal
    ld bc,Vec2
    ldir
    
Collide8:

;	if (faceB.y > relativeTol * separation + absoluteTol * hB.y)
;	{
;		axis = FACE_B_Y
;		separation = faceB.y
;		normal = dB.y > 0.0f ? RotB.col2 : minusVec2(RotB.col2)
;	}

    ld a,$3E; 0.95 (relativeTol)
    ld h,$E6
    ld l,$66

    ld ix,Collide_separation
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24mul
    
    push af
    push hl

    ld a,$38; 0.01 (absoluteTol)
    ld h,$47 
    ld l,$AE
    
    ld ix,Collide_hB
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24mul
    
    ld c,a
    ld d,h
    ld e,l
    
    pop hl
    pop af
    
    call f24add
    
    ld c,a
    ld d,h
    ld e,l
    
    ld ix,Collide_faceB+3
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    call f24cmp
    
    jr c,Collide9
    jr z,Collide9
    
    ld a,FACE_B_Y
    ld (Collide_axis),a
    
    ld hl,Collide_faceB+3
    ld de,Collide_separation
    ld bc,3
    ldir

    ld ix,Collide_dB
    ld a,(ix+3)
    ld h,(ix+4)
    ld l,(ix+5)
    
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp
    jr c,Collide9a
    jr z,Collide9a
    
    ld hl,Collide_RotB+Mat22_col2
    jr Collide9b

Collide9a:    
    ld hl,Collide_RotB+Mat22_col2
    ld de,minusVec2_v
    ld bc,Vec2
    ldir

    call minusVec2
    ld hl,minusVec2_res    

Collide9b:    
    ld de,Collide_normal
    ld bc,Vec2
    ldir
    
Collide9:
        
    ld ix,Collide_incidentEdge
    call initClipVertex
        
    ld ix,Collide_incidentEdge+ClipVertex
    call initClipVertex

; The Switch
; case FACE_A_X
    
    ld a,(Collide_axis)
    cp FACE_A_X
    jp nz,case2
    
    ld hl,Collide_normal
    ld de,Collide_frontNormal
    ld bc,Vec2
    ldir    
    
    ld hl,Collide_posA
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_frontNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld ix,Dot_res
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hA
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_front
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld hl,Collide_RotA+Mat22_col2
    ld de,Collide_sideNormal
    ld bc,Vec2
    ldir

    ld hl,Collide_posA
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_sideNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld hl,Dot_res
    ld de,Collide_side
    ld bc,3
    ldir
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    call f24neg
    
    ld ix,Collide_hA
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_negSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hA
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_posSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld a,EDGE3
    ld (Collide_negEdge),a
    
    ld a,EDGE1
    ld (Collide_posEdge),a
    
    ld ix,Collide_incidentEdge

    ld hl,Collide_hB
    ld de,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld hl,Collide_posB    
    ld de,ComputeIncidentEdge_pos
    ld bc,Vec2
    ldir

    ld hl,Collide_RotB
    ld de,ComputeIncidentEdge_Rot
    ld bc,Mat22
    ldir
    
    ld hl,Collide_frontNormal
    ld de,ComputeIncidentEdge_normal
    ld bc,Vec2
    ldir
    
    call ComputeIncidentEdge
    jp case_end

; case FACE_A_Y
    
case2:    
    ld a,(Collide_axis)
    cp FACE_A_Y
    jp nz,case3

    ld hl,Collide_normal
    ld de,Collide_frontNormal
    ld bc,Vec2
    ldir    
    
    ld hl,Collide_posA
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_frontNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld ix,Dot_res
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hA
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_front
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld hl,Collide_RotA
    ld de,Collide_sideNormal
    ld bc,Vec2
    ldir

    ld hl,Collide_posA
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_sideNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld hl,Dot_res
    ld de,Collide_side
    ld bc,3
    ldir
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    call f24neg
    
    ld ix,Collide_hA
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_negSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hA
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_posSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld a,EDGE2
    ld (Collide_negEdge),a
    
    ld a,EDGE4
    ld (Collide_posEdge),a
    
    ld ix,Collide_incidentEdge

    ld hl,Collide_hB
    ld de,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld hl,Collide_posB    
    ld de,ComputeIncidentEdge_pos
    ld bc,Vec2
    ldir

    ld hl,Collide_RotB
    ld de,ComputeIncidentEdge_Rot
    ld bc,12
    ldir
    
    ld hl,Collide_frontNormal
    ld de,ComputeIncidentEdge_normal
    ld bc,Vec2
    ldir
    
    call ComputeIncidentEdge
    
    jp case_end

; case FACE_B_X

case3:    
    ld a,(Collide_axis)
    cp FACE_B_X
    jp nz,case4

    ld hl,Collide_normal
    ld de,minusVec2_v
    ld bc,Vec2
    ldir    
    
    call minusVec2
    
    ld hl,minusVec2_res
    ld de,Collide_frontNormal
    ld bc,Vec2
    ldir
    
    ld hl,Collide_posB
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_frontNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld ix,Dot_res
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hB
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_front
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld hl,Collide_RotB+Mat22_col2
    ld de,Collide_sideNormal
    ld bc,Vec2
    ldir

    ld hl,Collide_posB
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_sideNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld hl,Dot_res
    ld de,Collide_side
    ld bc,3
    ldir
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    call f24neg
    
    ld ix,Collide_hB
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_negSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hB
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_posSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld a,EDGE3
    ld (Collide_negEdge),a
    
    ld a,EDGE1
    ld (Collide_posEdge),a
    
    ld ix,Collide_incidentEdge

    ld hl,Collide_hA
    ld de,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld hl,Collide_posA
    ld de,ComputeIncidentEdge_pos
    ld bc,Vec2
    ldir

    ld hl,Collide_RotA
    ld de,ComputeIncidentEdge_Rot
    ld bc,12
    ldir
    
    ld hl,Collide_frontNormal
    ld de,ComputeIncidentEdge_normal
    ld bc,Vec2
    ldir
    
    call ComputeIncidentEdge
    jp case_end

; case FACE_B_Y

case4:    
    ld a,(Collide_axis)
    cp FACE_B_Y
    jp nz,case_end

    ld hl,Collide_normal
    ld de,minusVec2_v
    ld bc,Vec2
    ldir    
    
    call minusVec2
    
    ld hl,minusVec2_res
    ld de,Collide_frontNormal
    ld bc,Vec2
    ldir
    
    ld hl,Collide_posB
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_frontNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld ix,Dot_res
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hB
    ld c,(ix+3)
    ld d,(ix+4)
    ld e,(ix+5)
    
    call f24add
    
    ld ix,Collide_front
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld hl,Collide_RotB
    ld de,Collide_sideNormal
    ld bc,Vec2
    ldir

    ld hl,Collide_posB
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_sideNormal
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot
    
    ld hl,Dot_res
    ld de,Collide_side
    ld bc,3
    ldir
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    call f24neg
    
    ld ix,Collide_hB
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_negSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld ix,Collide_side
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_hB
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24add
    
    ld ix,Collide_posSide
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
    
    ld a,EDGE2
    ld (Collide_negEdge),a
    
    ld a,EDGE4
    ld (Collide_posEdge),a
    
    ld ix,Collide_incidentEdge

    ld hl,Collide_hA
    ld de,ComputeIncidentEdge_h
    ld bc,Vec2
    ldir

    ld hl,Collide_posA    
    ld de,ComputeIncidentEdge_pos
    ld bc,Vec2
    ldir

    ld hl,Collide_RotA
    ld de,ComputeIncidentEdge_Rot
    ld bc,12
    ldir
    
    ld hl,Collide_frontNormal
    ld de,ComputeIncidentEdge_normal
    ld bc,Vec2
    ldir
    
    call ComputeIncidentEdge

case_end:

    ld ix,Collide_clipPoints1
    call initClipVertex

    ld ix,Collide_clipPoints1+ClipVertex
    call initClipVertex

    ld ix,Collide_clipPoints2
    call initClipVertex

    ld ix,Collide_clipPoints2+ClipVertex
    call initClipVertex

; np = ClipSegmentToLine(clipPoints1, incidentEdge, minusVec2(sideNormal), negSide, negEdge)

; if (np < 2)
; return 0

; NB: int ClipSegmentToLine(struct ClipVertex vOut[2], struct ClipVertex vIn[2],
;                       struct Vec2 normal, float offset, char clipEdge)
; ix points to vOut, iy points to vIn


    ld ix,Collide_clipPoints1
    ld iy,Collide_incidentEdge

    ld hl,Collide_sideNormal
    ld de,minusVec2_v
    ld bc,Vec2
    ldir

    call minusVec2

    ld hl,minusVec2_res
    ld de,ClipSegmentToLine_normal
    ld bc,Vec2
    ldir

    ld hl,Collide_negSide
    ld de,ClipSegmentToLine_offset
    ld bc,3
    ldir
    
    ld a,(Collide_negEdge)
    ld (ClipSegmentToLine_clipEdge),a
            
    call ClipSegmentToLine
    
    cp 2
    ld a,0

    pop iy
    pop ix
    
    ret c
    
    push ix
    push iy
    
;	np = ClipSegmentToLine(clipPoints2, clipPoints1,  sideNormal, posSide, posEdge)

;	if (np < 2)
;		return 0
    
    ld ix,Collide_clipPoints2
    ld iy,Collide_clipPoints1
    
    ld hl,Collide_sideNormal
    ld de,ClipSegmentToLine_normal
    ld bc,Vec2
    ldir

    ld hl,Collide_posSide
    ld de,ClipSegmentToLine_offset
    ld bc,3
    ldir
    
    ld a,(Collide_posEdge)
    ld (ClipSegmentToLine_clipEdge),a
    
    call ClipSegmentToLine
    
    cp 2
    ld a,0
    pop iy
    pop ix
    
    ret c
    
    push ix
    push iy
    
;		float separation = Dot(frontNormal, clipPoints2[i].v) - front
;
;		if (separation <= 0)
;		{
;			contacts[numContacts].separation = separation
;			contacts[numContacts].normal = normal
;			// slide contact point onto reference face (easy to cull)
;			contacts[numContacts].position = diffVec2(clipPoints2[i].v, scaledVec2(separation, frontNormal))
;			contacts[numContacts].feature = clipPoints2[i].fp
;			if (axis == FACE_B_X || axis == FACE_B_Y)
;				Flip(&contacts[numContacts].feature)
;			++numContacts
;		}

; in this loop we will store 
; iy=clipPoints2[i]
; contacts[numContacts].feature is on the stack
; Collide_contacts stores an advancing pointer contacts[numContacts]

    ld a,0
    ld (Collide_numContacts),a
    
    ld a,0  ; loop counter 0,1
CollideLoop:
    push af

    ld hl,Collide_frontNormal
    ld de,Dot_a
    ld bc,Vec2
    ldir
    
    ld hl,Collide_clipPoints2
    
    pop af ; loop counter
    push af
    ld de,ClipVertex
    call arrayIndex
    push hl
    pop iy ; store clipPoints2[i]
    
    ld de,Dot_b
    ld bc,Vec2
    ldir
    
    call Dot

    ld ix,Dot_res
    ld a,(ix+0)
    ld h,(ix+1)
    ld l,(ix+2)
    
    ld ix,Collide_front
    ld c,(ix+0)
    ld d,(ix+1)
    ld e,(ix+2)
    
    call f24sub
    
    ld ix,Collide_separation
    ld (ix+0),a
    ld (ix+1),h
    ld (ix+2),l
            
    ld c,0
    ld d,0
    ld e,0
    
    call f24cmp
    
    ; jump if separation > 0
    jr z,Collide11
    jp nc,Collide10
Collide11:

    ld hl,(Collide_contacts)
    ld de,Contact_separation
    add hl,de
    ex de,hl
    ld hl,Collide_separation
    ld bc,3
    ldir
    
    ld hl,(Collide_contacts)
    ld de,Contact_normal
    add hl,de
    ex de,hl
    ld hl,Collide_normal
    ld bc,Vec2
    ldir
    
    ld hl,Collide_separation
    ld de,scaledVec2_s
    ld bc,3
    ldir
    
    ld hl,Collide_frontNormal
    ld de,scaledVec2_v
    ld bc,Vec2
    ldir
    
    call scaledVec2
    
    ld hl,scaledVec2_res
    ld de,diffVec2_b
    ld bc,Vec2
    ldir

    push iy ; clipPoints2
    pop hl    
    ld de,diffVec2_a
    ld bc,Vec2
    ldir
    
    call diffVec2
    
    ld hl,(Collide_contacts)
    ld de,Contact_position
    add hl,de
    ex de,hl
    ld hl,diffVec2_res
    ld bc,Vec2
    ldir

;    NEED TO SET HL
    ld hl,(Collide_contacts)    
    ld de,Contact_feature
    add hl,de
    push hl ; store pointer contacts[numContacts].feature
    ex de,hl
    push iy
    pop hl   ; clipPoints2[i] stored earlier
    ld bc,ClipVertex_fp
    add hl,bc
    ld bc,Edges
    ldir

    pop ix ; contacts[numContacts].feature

    ld a,(Collide_axis)
    cp FACE_B_X
    jr z,Collide12 ; do it
    
    cp FACE_B_Y
    jr z,Collide12 ; do it
    
    jr Collide13   ; condition not met so don't do it

Collide12:
    
    call Flip ; pass in ix = contacts[numContacts].feature

Collide13:
    ld a,(Collide_numContacts)
    inc a
    ld (Collide_numContacts),a

    ld hl,(Collide_contacts)
    ld de,Contact
    add hl,de
    ld (Collide_contacts),hl
    
Collide10:    

    pop af
    inc a
    cp 2
    jp nz, CollideLoop
   
    ld a,(Collide_numContacts)
	
	pop iy
	pop ix
    ret
   
; ################################################################   
   
; ----------------------------------------------------------------
; There are routines in z80float but they seem overkill.
; I just need to convert a byte to ASCII and put in (HL)
; Example: convert a=56 as "056"
; input: a = number, HL=pointer to memory to store string (must be big enough)
; Output: a=0, string placed into (HL)
; destroys af,bc
; ----------------------------------------------------------------

u8toa:
	 ld	c,-100
	 call	Na1
	 ld	c,-10
	 call	Na1
	 ld	c,-1
Na1: ld	b,'0'-1
Na2: inc	b
	 add	a,c
	 jr	c,Na2
	 sub	c		;works as add 100/10/1
     ld (hl),b               ; digit in b
     inc hl
	 ret

; ----------------------------------------------------------------
; convert a to hex string and store in string at HL
; ----------------------------------------------------------------

u8toh:
        ld c,-16
        call u8toh1
        ld c,-1
u8toh1: ld  b,'0'-1 ; 47
u8toh2: inc b
        add a,c
        jr c,u8toh2
        sub c

        push af
        ld a,b    ; if (a>=58) a+=7; (jump past if a<58)
        cp 58     ; a=48 carry ... a=57 carry, a=58 no carry
        jr c, u8toh3
        add a,7     ; 65 - 58
u8toh3: ld b,a
        pop af

        ld (hl),b               ; digit in b
        inc hl
        ret

; ----------------------------------------------------------------
; SPECTRUM SPECIFIC and affects IX
; These print routines from Cliffhanger in INPUT magazine.
; I could have used ROM RSTs but don't like them!
; "me" prints text string (data: IX) length "B" on the screen at position "HL", colour "A". 
; increases ix and hl so can be called multiple times to print more text
; "cl" clears the screen but doesn't change attributes
; "print" draws a single UDG at HL, colour A, glyph data at BC. Can also be used for simple Sprites
; ----------------------------------------------------------------

me    push bc
      push af
      ld a,(ix+0)
      call asc
      pop af
      call print
      inc hl
      inc ix
      pop bc
      djnz me
      ret

asc   push hl        ; helper routine used by "me"
      ld hl,15608    ; beginning of char set glyphs in Spectrum ROM
      ld de,8
      ld b,31
      sub b
ash   add hl,de
      dec a
      jr nz,ash
      push hl
      pop bc
      pop hl
      ret

cl    ld ix,16384    ; beginning of screen memory
      ld hl,6144     ; length of screen memory excl. attributes
      ld a,0
clp   ld (ix+0),a
      inc ix
      dec hl
      push hl
      ld de,0
      sbc hl,de
      pop hl
      jr nz,clp
      ret

print push af         ; helper used by "me" and extensively below
      push hl         ; Draw single UDG at HL, colour a, gfx data at BC
      push bc
      push hl
      pop de
      ld a,d
      cp 1
      jr c,next
      push de
      ld de,1792
      add hl,de
      pop de
      ld a,d
      cp 1
      jr z,next
      push de
      ld de,1792
      add hl,de
      pop de
next  push de
      ld de,16384
      add hl,de
      pop de
      ld a,8
      pop bc
      push af
rpt   ld a,(bc)   ; INPUT used 'rept' but we can't as it seems to be an assembler directive
      ld (hl),a
      inc h
      inc bc
      pop af
      dec a
      jr z,exit
      push af
      jr rpt
exit  pop hl
      pop af      ; passed in value of A
      push de
      ld de,22528 ; beginning of attributes area
      add hl,de
      pop de
      ld (hl),a
      push de
      pop hl
      ret

include "f24.z80"
